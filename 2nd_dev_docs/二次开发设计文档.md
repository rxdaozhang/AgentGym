# AgentGym二次开发设计文档

## 一、项目扩展需求概述

本文档详细描述如何扩展AgentGym框架以支持以下功能：

1. 新增数据集支持：GAIA、Webshop、Agenttuning、agentcompany
2. 服务器端并行请求处理
3. 异步roll out和训练服务
4. 灵活替换RL训练框架

## 二、新增数据集支持方案

### 2.1 数据集环境服务器实现

#### 2.1.1 目录结构

```
AgentGym/
├── agentenv-gaia/             # GAIA环境服务器实现
├── agentenv-agenttuning/      # Agenttuning环境服务器实现
├── agentenv-agentcompany/     # agentcompany环境服务器实现
└── agentenv-webshop/          # 已存在，可能需要扩展
```

#### 2.1.2 环境服务器实现原型

每个新环境需实现以下基础类：

```python
# 以GAIA为例
class GAIAEnvServer:
    def __init__(self, config):
        self.config = config
        self.env_instances = {}

    async def create_env(self, env_id, params):
        """创建环境实例"""
        self.env_instances[env_id] = GAIAEnvironment(params)
        return {"env_id": env_id, "status": "created"}

    async def get_observation(self, env_id):
        """获取当前环境观察"""
        return self.env_instances[env_id].get_observation()

    async def get_available_actions(self, env_id):
        """获取可用动作"""
        return self.env_instances[env_id].get_available_actions()

    async def step(self, env_id, action):
        """执行动作"""
        return self.env_instances[env_id].step(action)

    async def reset(self, env_id, params=None):
        """重置环境"""
        return self.env_instances[env_id].reset(params)
```

### 2.2 环境客户端实现

在`agentenv/agentenv/envs/`目录下实现对应的客户端类：

```python
# 以GAIA为例
class GAIAEnvClient(BaseEnvClient):
    conversation_start = ("我是GAIA环境助手，请告诉我你想要做什么？",)

    def __init__(self, server_url, dataset_path=None):
        super().__init__()
        self.server_url = server_url
        self.dataset = self._load_dataset(dataset_path)
        self.current_state = None
        self.env_id = None

    def __len__(self) -> int:
        return len(self.dataset)

    def observe(self) -> str:
        """获取环境观察"""
        response = requests.get(f"{self.server_url}/observation", 
                                params={"env_id": self.env_id})
        return response.json()["observation"]

    def step(self, action) -> StepOutput:
        """执行动作并获取结果"""
        response = requests.post(f"{self.server_url}/step",
                                json={"env_id": self.env_id, "action": action})
        result = response.json()
        return StepOutput(
            observation=result["observation"],
            reward=result.get("reward", 0),
            done=result.get("done", False),
            info=result.get("info", {})
        )

    def reset(self, idx: int) -> None:
        """重置环境到指定索引"""
        if self.env_id is None:
            response = requests.post(f"{self.server_url}/createEnv")
            self.env_id = response.json()["env_id"]

        requests.post(f"{self.server_url}/reset",
                     json={"env_id": self.env_id, "idx": idx})
        self.current_state = self.observe()
```

### 2.3 任务类实现

```python
class GAIATask(BaseTask):
    env_client_cls = GAIAEnvClient
    env_name = "gaia"

    def __init__(self, client_args, n_clients=1):
        super().__init__(client_args, n_clients)

    def _tokenize_conversation_one(self, conversation):
        # 处理GAIA特定的对话格式
        return super()._tokenize_conversation_one(conversation)
```

## 三、服务器端并行请求支持

### 3.1 异步HTTP服务器设计

使用FastAPI框架实现异步HTTP服务器：

```python
# 环境服务器基类
class BaseAsyncEnvServer:
    def __init__(self, max_concurrent_envs=100):
        self.env_instances = {}
        self.env_locks = {}
        self.max_concurrent_envs = max_concurrent_envs

    async def create_env(self, env_id):
        """异步创建环境"""
        if len(self.env_instances) >= self.max_concurrent_envs:
            raise Exception("达到最大并发环境数量限制")

        self.env_instances[env_id] = self._create_env_instance()
        self.env_locks[env_id] = asyncio.Lock()
        return {"env_id": env_id, "status": "created"}

    async def step(self, env_id, action):
        """异步执行动作"""
        async with self.env_locks[env_id]:
            return await self._async_step(self.env_instances[env_id], action)

    async def _async_step(self, env_instance, action):
        """实际的异步步骤执行"""
        raise NotImplementedError()
```

### 3.2 FastAPI接口实现

```python
# 以GAIA为例
from fastapi import FastAPI, HTTPException
import uvicorn
import uuid

app = FastAPI()
server = GAIAAsyncEnvServer()

@app.post("/createEnv")
async def create_env():
    env_id = str(uuid.uuid4())
    result = await server.create_env(env_id)
    return result

@app.get("/observation")
async def get_observation(env_id: str):
    if env_id not in server.env_instances:
        raise HTTPException(status_code=404, detail="Environment not found")
    async with server.env_locks[env_id]:
        return await server.get_observation(env_id)

@app.post("/step")
async def step(request: dict):
    env_id = request.get("env_id")
    action = request.get("action")
    if env_id not in server.env_instances:
        raise HTTPException(status_code=404, detail="Environment not found")
    return await server.step(env_id, action)

@app.post("/reset")
async def reset(request: dict):
    env_id = request.get("env_id")
    idx = request.get("idx")
    if env_id not in server.env_instances:
        raise HTTPException(status_code=404, detail="Environment not found")
    async with server.env_locks[env_id]:
        return await server.reset(env_id, idx)

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

## 四、异步Roll Out和训练服务

### 4.1 数据库设计

使用MongoDB存储轨迹数据：

```python
# 数据模型
class TrajectoryModel:
    def __init__(self):
        self.client = pymongo.MongoClient("mongodb://localhost:27017/")
        self.db = self.client["agentgym"]
        self.trajectories = self.db["trajectories"]

    async def save_trajectory(self, traj_data):
        """保存轨迹到数据库"""
        doc = {
            "traj_id": str(uuid.uuid4()),
            "env_name": traj_data["env_name"],
            "task_id": traj_data["task_id"],
            "agent_id": traj_data["agent_id"],
            "timestamp": datetime.now(),
            "trajectory": traj_data["trajectory"],
            "metrics": traj_data.get("metrics", {})
        }
        await self.trajectories.insert_one(doc)
        return doc["traj_id"]

    async def get_trajectories(self, query=None, limit=100):
        """获取轨迹数据"""
        if query is None:
            query = {}
        cursor = self.trajectories.find(query).limit(limit)
        return await cursor.to_list(length=limit)
```

### 4.2 异步Roll Out控制器

```python
class AsyncRolloutController(BaseAgentEnvController):
    def __init__(self, agent, task, db_model=None):
        super().__init__(agent, task)
        self.db_model = db_model or TrajectoryModel()

    async def rollout(self, generation_config, max_rounds, idxs):
        """异步执行roll out"""
        results = []
        for idx in idxs:
            exp_output = await self._rollout_one(idx, generation_config, max_rounds)
            # 保存到数据库
            traj_data = {
                "env_name": self.task.env_name,
                "task_id": idx,
                "agent_id": getattr(self.agent, "id", "unknown"),
                "trajectory": exp_output.to_dict(),
            }
            await self.db_model.save_trajectory(traj_data)
            results.append(exp_output)
        return results

    async def _rollout_one(self, idx, generation_config, max_rounds):
        """异步执行单个环境的roll out"""
        self.task.reset(idx)
        conversation = list(self.task.conversation_start)
        for _ in range(max_rounds):
            # 异步获取观察
            observation = await self.task.observe_async()
            conversation.append(observation)

            # 生成动作
            inputs = self.task._tokenize_conversation(conversation)
            outputs = self.agent.model.generate(**inputs, **generation_config)
            action = self.agent.tokenizer.decode(outputs[0], skip_special_tokens=True)

            # 异步执行动作
            step_output = await self.task.step_async(action)
            conversation.append(action)

            if step_output.done:
                break

        return ExperienceOutput(
            conversation=conversation,
            reward=step_output.reward,
            done=step_output.done,
            info=step_output.info
        )
```

### 4.3 异步训练器

```python
class AsyncTrainer(BaseTrainer):
    def __init__(self, agent, task, db_model=None, **kwargs):
        super().__init__(agent, task, **kwargs)
        self.db_model = db_model or TrajectoryModel()

    async def train(self, batch_size=16, learning_rate=2e-5, epochs=3):
        """异步训练方法"""
        # 从数据库获取轨迹
        trajectories = await self.db_model.get_trajectories(
            query={"env_name": self.task.env_name},
            limit=1000
        )

        # 准备训练数据
        train_data = self._prepare_training_data(trajectories)

        # 训练模型
        optimizer = torch.optim.AdamW(self.agent.model.parameters(), lr=learning_rate)
        self.agent.model.train()

        for epoch in range(epochs):
            total_loss = 0
            for batch in self._get_batches(train_data, batch_size):
                optimizer.zero_grad()
                outputs = self.agent.model(**batch)
                loss = outputs.loss
                loss.backward()
                optimizer.step()
                total_loss += loss.item()

            print(f"Epoch {epoch+1}, Loss: {total_loss}")

        return {"status": "complete", "epochs": epochs, "final_loss": total_loss}
```

## 五、RL训练框架替换支持

### 5.1 抽象RL框架接口

```python
class RLFramework(metaclass=ABCMeta):
    @abstractmethod
    def train(self, agent, env, config):
        """训练方法"""
        pass

    @abstractmethod
    def evaluate(self, agent, env, config):
        """评估方法"""
        pass

    @abstractmethod
    def save_model(self, agent, path):
        """保存模型"""
        pass

    @abstractmethod
    def load_model(self, agent, path):
        """加载模型"""
        pass
```

### 5.2 VERL框架适配器

```python
class VERLAdapter(RLFramework):
    def __init__(self, verl_config=None):
        self.verl_config = verl_config or {}

    def train(self, agent, env, config):
        """使用VERL框架训练智能体"""
        import verl

        # 转换AgentGym的环境为VERL可接受的环境
        verl_env = self._convert_to_verl_env(env)

        # 创建VERL训练器
        trainer = verl.PPOTrainer(
            policy=self._wrap_agent_as_policy(agent),
            env=verl_env,
            **self.verl_config
        )

        # 执行训练
        results = trainer.train(**config)
        return results

    def _convert_to_verl_env(self, env):
        """将AgentGym环境转换为VERL环境"""
        # 实现环境转换逻辑
        pass

    def _wrap_agent_as_policy(self, agent):
        """将AgentGym智能体包装为VERL策略"""
        # 实现策略包装逻辑
        pass
```

### 5.3 RL训练器基类扩展

```python
class PluggableRLTrainer(BaseTrainer):
    def __init__(self, agent, task, rl_framework, **kwargs):
        super().__init__(agent, task, **kwargs)
        self.rl_framework = rl_framework

    def train(self, rl_config=None):
        """使用可插拔RL框架训练智能体"""
        rl_config = rl_config or {}
        return self.rl_framework.train(self.agent, self.task, rl_config)

    def eval(self, generation_config, max_rounds, idxs):
        """使用可插拔RL框架评估智能体"""
        eval_config = {
            "generation_config": generation_config,
            "max_rounds": max_rounds,
            "idxs": idxs
        }
        return self.rl_framework.evaluate(self.agent, self.task, eval_config)
```

## 六、开发工作计划

### 6.1 环境扩展

  - 设计并实现GAIA环境服务器和客户端
  - 扩展现有Webshop实现支持并行请求
  - 设计并实现Agenttuning环境
  - 设计并实现agentcompany环境

### 6.2 并行和异步支持

1. 实现异步HTTP服务器框架
  
  - 实现BaseAsyncEnvServer
  - 为所有环境服务器添加并行请求支持
2. 实现数据库和异步Roll Out
  
  - 实现MongoDB轨迹存储
  - 实现AsyncRolloutController
  - 实现AsyncTrainer

### 6.3 RL框架支持

1. 实现RL框架适配
  - 设计RLFramework接口
  - 实现VERLAdapter
  - 实现PluggableRLTrainer

### 6.4 测试和优化

1. 测试和调试
  
  - 为每个组件编写单元测试
  - 进行集成测试
  - 性能测试并进行优化
2. 文档和示例
  
  - 更新项目文档
  - 编写使用示例
  - 准备演示

## 七、技术挑战与解决方案

1. **环境复杂性**：不同环境具有不同特性
  
  - 解决方案：设计灵活的接口，允许环境特定的扩展
2. **并行性能**：并行处理大量请求可能导致资源竞争
  
  - 解决方案：使用异步锁和连接池管理资源
3. **数据一致性**：异步操作可能导致数据不一致
  
  - 解决方案：使用事务和乐观锁确保数据一致性
4. **框架兼容性**：不同RL框架有不同的接口
  
  - 解决方案：设计抽象适配器模式，隔离框架差异

## 八、总结

本文档详细描述了AgentGym框架的二次开发设计，包括新增数据集支持、服务器端并行请求处理、异步roll out和训练服务以及灵活的RL训练框架替换。通过这些扩展，AgentGym将能够支持更多环境、提高并发性能并增强系统的可扩展性。